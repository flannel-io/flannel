package main

// rootfs2vhd is a simple utility to convert rootfs.tar.gz generated by
// the Microsoft/opengcs repos build.ps1 script to rootfs.vhd which LCOW
// can use for the root filesystem added on VPMem (as opposed to an initrd).
//
// It's not pretty, but enough to get the job done. It does require
// the Hyper-V RSAT to be installed for shelling out to New-VHD.

import (
	"bufio"
	"bytes"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"

	"github.com/Microsoft/hcsshim/internal/lcow"
	"github.com/Microsoft/hcsshim/internal/uvm"
	"github.com/Microsoft/hcsshim/internal/wclayer"
	specs "github.com/opencontainers/runtime-spec/specs-go"
	"github.com/sirupsen/logrus"
	"github.com/urfave/cli"
)

var (
	debug = false
	pause = false
)

func main() {

	app := cli.NewApp()
	cwd, _ := filepath.Abs("./")

	app.Flags = []cli.Flag{
		cli.StringFlag{
			Name:  "i",
			Usage: "Full path to .tar.gz of the root file system to be converted",
			Value: cwd + `\rootfs.tar.gz`,
		},
		cli.StringFlag{
			Name:  "o",
			Usage: "Full path to output filename",
			Value: cwd + `\rootfs.vhd`,
		},
		cli.IntFlag{
			Name:  "s",
			Usage: "Size in MB of the new VHD",
			Value: 19,
		},
		cli.BoolFlag{
			Name:  "D",
			Usage: "Debug mode",
		},
		cli.BoolFlag{
			Name:  "P",
			Usage: "Pause when complete but before tearing down the utility VM",
		},
	}
	app.Action = func(c *cli.Context) {
		rootfs2vhd(c)
	}
	fmt.Printf("\nrootfs2vhd: Converts an LCOW root filesystem tar.gz to a VHD\n\n")
	if err := app.Run(os.Args); err != nil {
		os.Exit(-1)
	}
}

func rootfs2vhd(c *cli.Context) {
	sourceRootFS := c.String("i")
	destFile := c.String("o")
	debug = c.Bool("D")
	pause = c.Bool("P")

	if debug {
		logrus.SetLevel(logrus.DebugLevel)
		logrus.SetFormatter(&logrus.TextFormatter{FullTimestamp: true})
	}

	if _, err := os.Stat(sourceRootFS); err != nil {
		fmt.Fprintf(os.Stderr, "%s not found\n", sourceRootFS)
		os.Exit(-1)
	}

	if _, err := os.Stat(destFile); err == nil {
		fmt.Fprintf(os.Stderr, "%s exists. Not overwriting\n", destFile)
		os.Exit(-1)
	}

	// TODO The right thing to do here is modify go-winio to be able to create this type of disk.
	fmt.Printf("- Creating %s...\n", destFile)
	if _, err := exec.Command(`powershell`, `-command`, fmt.Sprintf(`New-VHD %s -SizeBytes %dMB -fixed`, destFile, c.Int("s"))).Output(); err != nil {
		fmt.Fprintf(os.Stderr, string(err.(*exec.ExitError).Stderr))
		os.Exit(-1)
	}

	fmt.Println("- Creating an LCOW utility VM...")
	lcowUVM, err := uvm.Create(&uvm.UVMOptions{OperatingSystem: "linux", ID: "rootfs2vhd"})
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to create utility VM: %s", err)
		os.Exit(-1)
	}

	fmt.Println("- Starting it....")
	if err := lcowUVM.Start(); err != nil {
		fmt.Fprintf(os.Stderr, "Failed to start utility VM: %s", err)
		os.Exit(-1)
	}

	fmt.Printf("- Adding %s as read-only...\n", filepath.Dir(sourceRootFS))
	if err := lcowUVM.AddPlan9(filepath.Dir(sourceRootFS), `/fssource`, true); err != nil {
		fmt.Fprintf(os.Stderr, "failed to add %s: %s", filepath.Dir(sourceRootFS), err)
		lcowUVM.Terminate()
		lcowUVM.Wait()
		os.Exit(-1)
	}

	fmt.Printf("- Granting access to %s...\n", destFile)
	if err := wclayer.GrantVmAccess(lcowUVM.ID(), destFile); err != nil {
		fmt.Fprintf(os.Stderr, "Failed to grant access: %s", err)
		lcowUVM.Terminate()
		lcowUVM.Wait()
		os.Exit(-1)
	}

	fmt.Println("- Hot-adding SCSI disk...")
	controller, lun, err := lcowUVM.AddSCSI(destFile, "") // No destination as not formatted
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to add SCSI: %s", err)
		lcowUVM.Terminate()
		lcowUVM.Wait()
		os.Exit(-1)
	}
	fmt.Printf("- Added at SCSI %d:%d\n", controller, lun)

	uvmCommand(lcowUVM, []string{"test", "-d", fmt.Sprintf("/sys/bus/scsi/devices/%d:0:0:%d", controller, lun)})
	device := fmt.Sprintf(`/dev/%s`, strings.TrimSpace(uvmCommand(lcowUVM, []string{"ls", fmt.Sprintf("/sys/bus/scsi/devices/%d:0:0:%d/block", controller, lun)})))
	fmt.Printf("- Located at %s\n", device)

	fmt.Printf("- Formatting ext4...\n")
	uvmCommand(lcowUVM, []string{"mkfs.ext4", "-q", "-E", "lazy_itable_init=1", "-O", `^has_journal,sparse_super2,uninit_bg,^resize_inode`, device})

	fmt.Printf("- Extracting %s...\n", filepath.Base(sourceRootFS))
	uvmCommand(lcowUVM, []string{"mkdir", "/target"})
	uvmCommand(lcowUVM, []string{"mount", device, "/target"})
	uvmCommand(lcowUVM, []string{"rm", "-rf", "/target/lost+found"})
	uvmCommand(lcowUVM, []string{"sh", "-c", fmt.Sprintf(`"cd /target; gzip -dc /fssource/%s | tar x"`, filepath.Base(sourceRootFS))})
	fmt.Println("- Extract complete!")
	fmt.Printf("\n%s\n", uvmCommand(lcowUVM, []string{"df", "/target"}))
	possiblePause()
	uvmCommand(lcowUVM, []string{"umount", device})

	fmt.Println("- Removing SCSI disk...")
	if err := lcowUVM.RemoveSCSI(destFile); err != nil {
		fmt.Fprintf(os.Stderr, "Failed to remove SCSI: %s", err)
		lcowUVM.Terminate()
		lcowUVM.Wait()
		os.Exit(-1)
	}

	lcowUVM.Terminate()

	fmt.Printf("\nSuccess\n")
	os.Exit(0)
}

func uvmCommand(lcowUVM *uvm.UtilityVM, args []string) string {
	timeout := 30 * time.Second
	var outB, errB bytes.Buffer
	p, _, err := lcow.CreateProcess(&lcow.ProcessOptions{
		HCSSystem:         lcowUVM.ComputeSystem(),
		CreateInUtilityVm: true,
		CopyTimeout:       timeout,
		Process:           &specs.Process{Args: args},
		Stdout:            &outB,
		Stderr:            &errB,
	})
	if err != nil {
		fmt.Fprintf(os.Stderr, "%+v failed:\n%s\n%s)", args, err, errB.String())
		possiblePause()
		lcowUVM.Terminate()
		os.Exit(-1)
	}
	defer p.Close()
	p.WaitTimeout(timeout)
	ec, err := p.ExitCode()
	if err != nil {
		fmt.Fprintf(os.Stderr, "%+v failed to get exit code:\n%s\n%s)", args, err, errB.String())
		possiblePause()
		lcowUVM.Terminate()
		os.Exit(-1)
	}
	if ec != 0 {
		fmt.Fprintf(os.Stderr, "%+v had non-zero exit code:\n%s)", args, errB.String())
		possiblePause()
		lcowUVM.Terminate()
		os.Exit(-1)
	}
	return outB.String()
}

func possiblePause() {
	if pause {
		fmt.Print("Press 'Enter' to continue...")
		bufio.NewReader(os.Stdin).ReadBytes('\n')
	}
}
